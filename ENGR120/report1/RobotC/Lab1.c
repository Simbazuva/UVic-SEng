#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           motor1,        tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define EXERCISE_NUMBER 	4 //WHEN YOU FINISH EACH EXERCISE, INCREMENT THIS VALUE

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input


/* monitorInput()
*
*  Used to flag button inputs
*       - this avoids errors caused by program recognizing input, taking action, and
*         reading input again before button is released
*/
void monitorInput()
{
  if(SensorValue(button1) && !button1_pushed)
  {
    button1_pushed = true;
  }

  if(SensorValue(button2) & !button2_pushed)
  {
    button2_pushed = true;
  }
}

void exercise_1()
{

	while(true)
	{
		monitorInput();
		if(button2_pushed){
			motor[port2]=0;
			button2_pushed=false;
		}
		if( button1_pushed ) {
			motor[port2]=50;
			button1_pushed=false;
		} // end if
	}//end while
}

void exercise_2()
{
  while(true)
  {
    monitorInput();
    if(button1_pushed)
		{
			motor[port2]=50;
			if(time1[timer1]>=3000){
				motor[port2]=0;
				button1_pushed=false;
				clearTimer(timer1);
			}
     } // end if
    }// end while

} // end exercise_2

void exercise_3()
{
	while(true)
	{
	  monitorInput();

    if(button1_pushed)
		{
			motor[port2]=50;
			if(SensorValue[I2C_1]>=627 || SensorValue[I2C_1]<=-627){
				motor[port2]=0;
				button1_pushed=false;
				SensorValue[I2C_1]=0;
			}


      /* INSERT CODE HERE
      * - make sure EXERCISE_NUMBER is set to 3
		  * - reset rotation sensor
      * - turn motor on
		  * - wait for rotation to reach 720
		  * - turn motor off, and clear button1_pushed flag
		  */

      }//end if
  }//end while

}//end exercse_3

void exercise_4()
{
	int val;
	typedef enum Robot_State {
  	Forward,
  	Backward,
  	Stop
  };
	Robot_State currentState = Stop;
	Robot_State nextState;
  while(true)
  {
    monitorInput();

    switch(currentState){
    	case Forward://----------------
				motor[port2]=50;
				button1_pushed=false;
				val=SensorValue[I2C_1];
				while(SensorValue[I2C_1]<=val+500 && SensorValue[I2C_1]>=val-500){
					if(SensorValue(button2)){
						button2_pushed = true;
					}else{
	    			nextState = Stop;
	    		}
				}
    		break;

    	case Backward://----------------
				motor[port2]=-50;
				button2_pushed=false;
				val=SensorValue[I2C_1];
				while(SensorValue[I2C_1]<=val+500 && SensorValue[I2C_1]>=val-500){
					if(SensorValue(button1)){
						button1_pushed = true;
					}else{
	    			nextState = Stop;
	    		}
    		}
    		break;

    	default://Stop-----------------
    		if(button1_pushed){
    			nextState = Forward;
    		}else if(button2_pushed){
    			nextState = Backward;
    		}else{
    			nextState = Stop;
    		}
    		motor[port2]=0;
    }
    currentState = nextState;
    /* INSERT CODE HERE
		* - use FSM design and methods used in previous exercises
		*   to achieve desired system behviour
		*/
  }//end while
}

task main()
{
	button1_pushed = button2_pushed = false;

	switch (EXERCISE_NUMBER)
  {
     case 1:
       exercise_1();
       break;
     case 2:
       exercise_2();
       break;
     case 3:
       exercise_3();
       break;
     case 4:
       exercise_4();
       break;
     default: //should never get here.
   } // end switch

}// end main
