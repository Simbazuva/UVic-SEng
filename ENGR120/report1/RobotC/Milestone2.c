#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    InfraCollector, sensorReflection)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           left_motor,    tmotorVex393_MC29, openLoop, reversed, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port9,           right_motor,   tmotorVex393_MC29, openLoop, driveRight, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*************************************************************************
VEX Program -ENGR 120/121 Light sensor lab

Description: This program performs the tasks for Milestone 2
							1. Moves in a straight line
							2. Turns exactly 90 degrees
							3. Moves the target object

	Breadboard connected to	- analog port 1 measures phototransistor
	                        - digital port 1 controls a red LED
	                        -
*************************************************************************/

// Threshold of value read from phototransistor circuit.
//const   int IR_SENSOR_THRESHOLD = 500;
//======================================================================
// Type of variable that will store the state values.
typedef enum T_task_state{
	BEGIN,
  TASK1,
  TASK2,
  TASK3
};
int system_counter = 0;
bool taskrun=false;
bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input
//======================================================================
// LED light control values.
//const   int OFF = 0;
//const   int ON  = 1;
//======================================================================
void monitorInput(){
  if(SensorValue(button1)){
    /*system_counter++;

    if(system_counter==1){
    	tcheck1=true;
    }else if(system_counter==2){
    	tcheck2=true;
    }
    waitInMilliseconds(200);*/
    button1_pushed = true;
  }
  if(SensorValue(button2)){
    //system_counter = 4;
  	button2_pushed = true;
  }
}
//======================================================================
//======================================================================
task main()
{

  // System state variable
  T_task_state system_state = BEGIN;
  // Endless loop
  while (true){
  	monitorInput();
  	if(button1_pushed || button2_pushed){
    	taskrun=true;
    }
    if(button1_pushed){
    	system_counter++;
    }
  	button1_pushed = false;
  	button2_pushed = false;
  	if(system_counter == 0 || system_counter == 3){
  		system_state = BEGIN;
  		system_counter = 0;
  	}else if(system_counter == 1){
  		system_state = TASK1;
  	}else if(system_counter == 2){
  		system_state = TASK2;
  	}else if(system_counter == 4){
  		system_state = TASK3;
  	}
    switch(system_state)
    {
    	//=================
      case(BEGIN):
        //Polling state
        break;
			//=================
      case(TASK1):
	    	while(taskrun){
	    		int forward_time = 2000; //TIME TO move forward
	    		motor[left_motor]=127;
	    		motor[right_motor]=127;
	    		if(time1[timer1]>=forward_time){
						motor[left_motor]=0;
	    			motor[right_motor]=0;
						clearTimer(timer1);
						taskrun=false;
					}
	    	}

	    	break;
			//=================
      case(TASK2):
      	if(taskrun){
      		int turn_time = 2000; //TIME TO TURN 90deg
	    		pointTurn(left, 127);
	    		if(time1[timer2]>=turn_time){
						stop();
						clearTimer(timer2);
					}
	    	}
      	taskrun=false;
        break;
			//=================
      case(TASK3):
        //DO NOTHING

      	system_counter=0;
      	break;
			//=================
    	default: // We should never be in this state.

    } // switch(system_state)

  } // while(true)

}
